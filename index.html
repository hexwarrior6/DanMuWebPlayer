<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="favicon.png" type="image/x-icon">
    <title>本地弹幕播放器</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/dplayer/dist/DPlayer.min.css">
    <style>
        body {
            font-family: "HarmonyOS Sans", "PingFang SC", "Helvetica Neue", Arial, sans-serif;
            background: #f6f7fb;
            margin: 0;
            padding: 0;
        }

        .main-layout {
            display: flex;
            flex-direction: row;
            gap: 32px;
            max-width: 80%;
            margin: 48px auto 0 auto;
            padding: 0 16px;
        }

        @media (max-width: 900px) {
            .main-layout {
                flex-direction: column;
                gap: 20px;
                margin-top: 24px;
            }

            .controls input[type="text"] {
                max-width: 100%;
                /* 新增：在移动端允许宽度自适应父容器 */
                min-width: 0;
                /* 新增：防止flex导致的溢出 */
            }
        }

        .player-card {
            flex: 2;
            background: #fff;
            border-radius: 28px;
            box-shadow: 0 6px 32px 0 rgba(30, 34, 40, 0.10);
            padding: 32px 32px 24px 32px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #dplayer {
            width: 100%;
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 2px 12px 0 rgba(0, 0, 0, 0.06);
            margin-bottom: 32px;
            position: relative;
            aspect-ratio: 16/9;
            min-height: 360px;
            /* 提供一个最小高度作为备用 */
        }

        /* DPlayer加载后会创建自己的容器，确保它填满父元素 */
        #dplayer .dplayer-video-wrap {
            width: 100%;
            height: 100%;
        }

        #video-placeholder {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #bbb;
            font-size: 22px;
            background: #f7f8fa;
            z-index: 2;
            pointer-events: none;
            height: 100%;
            width: 100%;
        }

        #video-placeholder .icon {
            font-size: 60px;
            margin-bottom: 18px;
            color: #e3e5e7;
        }

        .controls {
            display: flex;
            gap: 18px;
            margin-bottom: 0;
            width: 100%;
            justify-content: center;
        }

        input[type="text"] {
            flex: 1;
            padding: 14px 18px;
            border: 2px solid #e3e5e7;
            border-radius: 14px;
            font-size: 18px;
            outline: none;
            background: #f7f8fa;
            transition: border 0.2s;
            max-width: 400px;
            /* 新增：限制最大宽度，防止超出 */
        }

        input[type="text"]:focus {
            border-color: #00A1D6;
        }

        button,
        .file-label {
            border: none;
            border-radius: 14px;
            font-size: 18px;
            font-weight: 600;
            padding: 14px 22px;
            background: #222;
            color: #fff;
            cursor: pointer;
            transition: background 0.2s, box-shadow 0.2s;
            box-shadow: 0 2px 8px 0 rgba(0, 0, 0, 0.08);
        }

        button:hover,
        .file-label:hover {
            background: #444;
        }

        button:disabled {
            background: #b8c0cc;
            cursor: not-allowed;
        }

        .file-input {
            display: none;
        }

        .status {
            margin-top: 18px;
            padding: 14px;
            background: #f2f3f7;
            border-radius: 14px;
            color: #555;
            font-size: 16px;
            text-align: center;
        }

        .progress-container {
            margin-top: 18px;
            display: none;
        }

        progress {
            width: 100%;
            height: 18px;
            border-radius: 9px;
            overflow: hidden;
            background: #e3e5e7;
            accent-color: #00A1D6;
        }

        #progressText {
            color: #00A1D6;
            font-weight: 600;
            margin-top: 6px;
            font-size: 16px;
            text-align: center;
        }

        .info-card {
            flex: 1;
            background: linear-gradient(135deg, #fafdff 60%, #e9f3ff 100%);
            border-radius: 32px;
            box-shadow: 0 8px 36px 0 rgba(30, 34, 40, 0.13), 0 1.5px 6px 0 rgba(0, 161, 214, 0.06);
            padding: 38px 40px 32px 38px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 260px;
            max-width: 340px;
            border: 1.5px solid #e3e5e7;
            position: relative;
            overflow: hidden;
        }

        .avatar {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: #e3e5e7;
            margin-bottom: 22px;
            object-fit: cover;
            border: 3px solid #fff;
            box-shadow: 0 2px 12px 0 rgba(0, 161, 214, 0.08);
        }

        .info-title {
            font-size: 22px;
            font-weight: 800;
            color: #1a2233;
            margin-bottom: 10px;
            margin-top: 24px;
            letter-spacing: 1px;
        }

        .info-detail {
            font-size: 15.5px;
            color: #4a6fa1;
            margin-bottom: 18px;
            text-align: center;
            background: #f2f7fb;
            border-radius: 10px;
            padding: 8px 12px;
        }

        .info-section {
            width: 100%;
            margin-bottom: 16px;
            margin-top: 32px;
            position: relative;
        }

        .info-section:not(:first-child) {
            margin-top: 40px;
            /* 统一分割线和内容间距 */
        }

        .info-section:not(:first-child)::before {
            content: "";
            display: block;
            width: 70%;
            height: 1.5px;
            background: linear-gradient(90deg, #e3e5e7 0%, #b8c0cc 100%);
            margin: 0 auto 18px auto;
            border-radius: 1px;
        }

        .info-section ul {
            padding-left: 0;
            margin: 10px 0 0 0;
            color: #3a4a5a;
            font-size: 15px;
            list-style: none;
        }

        .info-section ul li {
            margin-bottom: 7px;
            display: flex;
            align-items: center;
        }

        .info-section ul li::before {
            content: "•";
            color: #00A1D6;
            font-size: 18px;
            margin-right: 8px;
            line-height: 1;
        }

        /* 弹幕速度滑块美化 */
        #speedSlider {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: linear-gradient(90deg, #00A1D6 0%, #e3e5e7 100%);
            outline: none;
            margin-top: 2px;
            margin-bottom: 0;
            accent-color: #00A1D6;
        }

        #speedSlider::-webkit-slider-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #fff;
            border: 2px solid #00A1D6;
            box-shadow: 0 2px 6px 0 rgba(0, 161, 214, 0.10);
            cursor: pointer;
            transition: background 0.2s;
        }

        #speedSlider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #fff;
            border: 2px solid #00A1D6;
            box-shadow: 0 2px 6px 0 rgba(0, 161, 214, 0.10);
            cursor: pointer;
            transition: background 0.2s;
        }

        #speedSlider::-ms-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #fff;
            border: 2px solid #00A1D6;
            box-shadow: 0 2px 6px 0 rgba(0, 161, 214, 0.10);
            cursor: pointer;
            transition: background 0.2s;
        }

        #speedValue {
            color: #00A1D6;
            font-weight: bold;
            font-size: 17px;
            margin-left: 6px;
        }
    </style>
</head>

<body>
    <div class="main-layout">
        <div class="player-card">
            <h1>本地弹幕播放器</h1>
            <div id="dplayer">
                <div id="video-placeholder">
                    <div class="icon">▶️</div>
                    <div>请先选择本地视频文件</div>
                </div>
            </div>
            <div class="controls">
                <input type="text" id="danmuInput" placeholder="输入弹幕内容">
                <button id="sendDanmu">发送</button>
            </div>
            <div class="progress-container" id="progressContainer">
                <progress id="loadProgress" value="0" max="100"></progress>
                <div id="progressText">加载中: 0%</div>
            </div>
            <div class="status" id="status">等待加载视频和弹幕...</div>
        </div>
        <div class="info-card">
            <img class="avatar" src="favicon.png" alt="favicon">
            <div class="info-title">欢迎使用</div>
            <div class="info-detail">本地弹幕播放器，支持本地视频与弹幕文件播放，体验极简风格。</div>
            <div class="info-section">
                <b>使用方法：</b>
                <ul style="padding-left: 18px; margin: 8px 0 0 0; color: #444; font-size: 14px;">
                    <li>选择本地视频和弹幕文件</li>
                    <li>点击播放，实时发送弹幕</li>
                    <li>支持批量加载与取消</li>
                </ul>
            </div>

            <!-- 新增弹幕速度调节滑块 -->
            <div class="info-section" style="margin-top: 20px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                    <b>弹幕速度：</b>
                    <span id="speedValue">1.0</span>
                </div>
                <input type="range" id="speedSlider" min="0.1" max="2" step="0.1" value="1"
                    style="width: 100%; height: 6px; border-radius: 3px; outline: none;">
            </div>

            <div
                style="margin-top:18px; width:100%; display:flex; margin-top:60px; flex-direction:column; gap:14px; align-items:center;">
                <label for="videoFile" class="file-label" style="width:80%;">选择视频</label>
                <input type="file" id="videoFile" class="file-input" accept="video/mp4">
                <label for="danmuFile" class="file-label" style="width:80%;">选择弹幕</label>
                <input type="file" id="danmuFile" class="file-input" accept=".xml">
            </div>
        </div>
    </div>

    <!-- 引入必要的库 -->
    <script src="https://cdn.jsdelivr.net/npm/dplayer/dist/DPlayer.min.js"></script>

    <script>
        // 全局变量
        let dp;
        let videoUrl = '';
        let danmuList = []; // 存储弹幕
        let loadingWorker = null;
        let isCancelled = false;

        updateStatus('请选择视频文件和弹幕文件');

        // 修改 initPlayer：选择视频后初始化 DPlayer，并隐藏占位层
        function initPlayer() {
            // 隐藏占位层
            const placeholder = document.getElementById('video-placeholder');
            if (placeholder) placeholder.style.display = 'none';

            // 获取当前设置的弹幕速度
            const speedRate = parseFloat(document.getElementById('speedSlider').value);

            // 添加全局样式控制弹幕速度
            let speedStyle = document.getElementById('danmu-speed-style');
            if (!speedStyle) {
                speedStyle = document.createElement('style');
                speedStyle.id = 'danmu-speed-style';
                document.head.appendChild(speedStyle);
            }

            // 计算动画时间
            const baseDuration = 8.5;
            const newDuration = baseDuration / speedRate;

            // 更新全局样式
            speedStyle.textContent = `.dplayer-danmaku-item { animation-duration: ${newDuration}s !important; }`;

            dp = new DPlayer({
                container: document.getElementById('dplayer'),
                autoplay: false,
                theme: '#FADFA3',
                video: {
                    url: videoUrl,
                    type: 'auto'
                },
                danmaku: {
                    id: 'local-danmu',
                    api: '',
                    maximum: 1000,
                    addition: [],
                    user: '观众',
                    speedRate: speedRate,
                },
                contextmenu: []
            });
            dp.seek(0);
            updateStatus(`播放器已初始化，等待加载弹幕...`);
        }

        // 更新状态显示
        function updateStatus(message) {
            document.getElementById('status').textContent = message;
        }

        // 批量加载弹幕
        function batchLoadDanmus(danmus, batchSize = 100) {
            const progressContainer = document.getElementById('progressContainer');
            const progressBar = document.getElementById('loadProgress');
            const progressText = document.getElementById('progressText');

            progressContainer.style.display = 'block';
            progressBar.value = 0;
            progressText.textContent = '加载中: 0%';

            let loaded = 0;
            const total = danmus.length;
            isCancelled = false;

            document.getElementById('cancelLoad').disabled = false;

            function loadNextBatch() {
                if (isCancelled) {
                    updateStatus(`已取消加载，已加载 ${loaded}/${total} 条弹幕`);
                    progressContainer.style.display = 'none';
                    document.getElementById('cancelLoad').disabled = true;
                    return;
                }

                const batchEnd = Math.min(loaded + batchSize, total);

                // 修改：逐条添加弹幕
                for (let i = loaded; i < batchEnd; i++) {
                    const danmu = danmus[i];
                    dp.danmaku && dp.danmaku.draw({
                        text: danmu.text,
                        color: danmu.color || '#ffffff',
                        type: danmu.type || 'right',
                        time: danmu.time
                    });
                }

                loaded = batchEnd;
                const percent = Math.round((loaded / total) * 100);
                progressBar.value = percent;
                progressText.textContent = `加载中: ${percent}% (${loaded}/${total})`;

                if (loaded < total) {
                    setTimeout(loadNextBatch, 0);
                } else {
                    updateStatus(`成功加载 ${total} 条弹幕`);
                    progressContainer.style.display = 'none';
                    document.getElementById('cancelLoad').disabled = true;
                }
            }

            loadNextBatch();
        }

        // 使用正则表达式解析XML (兼容Web Worker环境)
        function parseDanmuWithRegex(xmlText) {
            const danmuRegex = /<d p="([^"]+)">([^<]+)<\/d>/g;
            const result = [];
            let match;

            while ((match = danmuRegex.exec(xmlText)) !== null) {
                const attrs = match[1].split(',');
                const text = match[2];

                if (attrs.length >= 8) {
                    const time = parseFloat(attrs[0]);
                    const type = parseInt(attrs[1]);
                    const color = parseInt(attrs[3]);

                    if (type === 1) { // 只处理滚动弹幕
                        result.push({
                            text: text,
                            color: '#' + color.toString(16).padStart(6, '0'),
                            type: 'right',
                            time: time
                        });
                    }
                }
            }

            return result;
        }

        // 使用Web Worker解析XML (使用正则表达式替代DOMParser)
        function parseDanmuWithWorker(xmlText) {
            return new Promise((resolve, reject) => {
                if (window.Worker) {
                    const worker = new Worker(URL.createObjectURL(
                        new Blob([`
                            function parseDanmuXML(xmlText) {
                                try {
                                    const danmuRegex = /<d p="([^"]+)">([^<]+)<\\/d>/g;
                                    const result = [];
                                    let match;
                                    
                                    while ((match = danmuRegex.exec(xmlText)) !== null) {
                                        const attrs = match[1].split(',');
                                        const text = match[2];
                                        
                                        if (attrs.length >= 8) {
                                            const time = parseFloat(attrs[0]);
                                            const type = parseInt(attrs[1]);
                                            const color = parseInt(attrs[3]);
                                            
                                            if (type === 1) {
                                                result.push({
                                                    text: text,
                                                    color: '#' + color.toString(16).padStart(6, '0'),
                                                    type: 'right',
                                                    time: time
                                                });
                                            }
                                        }
                                    }
                                    return result;
                                } catch (error) {
                                    throw error;
                                }
                            }
                            
                            self.onmessage = function(e) {
                                try {
                                    const result = parseDanmuXML(e.data);
                                    self.postMessage({ success: true, data: result });
                                } catch (error) {
                                    self.postMessage({ success: false, error: error.message });
                                }
                            };
                        `], { type: 'application/javascript' })
                    ));

                    worker.onmessage = function (e) {
                        if (e.data.success) {
                            resolve(e.data.data);
                        } else {
                            reject(new Error(e.data.error));
                        }
                        worker.terminate();
                    };

                    worker.onerror = function (error) {
                        reject(error);
                        worker.terminate();
                    };

                    worker.postMessage(xmlText);
                } else {
                    // 浏览器不支持Web Worker，回退到主线程解析
                    try {
                        const result = parseDanmuWithRegex(xmlText);
                        resolve(result);
                    } catch (error) {
                        reject(error);
                    }
                }
            });
        }

        // 主线程解析XML (使用DOMParser)
        function parseDanmuXML(xmlText) {
            try {
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlText, "text/xml");
                const danmus = xmlDoc.getElementsByTagName('d');
                const result = [];

                for (let i = 0; i < danmus.length; i++) {
                    const danmu = danmus[i];
                    const attrs = danmu.getAttribute('p').split(',');

                    if (attrs.length >= 8) {
                        const time = parseFloat(attrs[0]);
                        const type = parseInt(attrs[1]);
                        const color = parseInt(attrs[3]);

                        if (type === 1) {
                            result.push({
                                text: danmu.textContent,
                                color: '#' + color.toString(16).padStart(6, '0'),
                                type: 'right',
                                time: time
                            });
                        }
                    }
                }

                return result;
            } catch (error) {
                updateStatus(`弹幕解析失败: ${error.message}`);
                console.error('XML解析错误:', error);
                return [];
            }
        }

        // 事件监听
        document.getElementById('sendDanmu').addEventListener('click', function () {
            const text = document.getElementById('danmuInput').value;
            if (text.trim() !== '' && dp) {
                // 获取当前速度设置
                const currentSpeed = dp.danmaku.speedRate;

                dp.danmaku.draw({
                    text: text,
                    color: '#ffffff',
                    type: 'right'
                });

                // 确保新发送的弹幕使用当前速度
                setTimeout(() => {
                    const danmuItems = document.querySelectorAll('.dplayer-danmaku-item');
                    if (danmuItems.length > 0) {
                        const lastItem = danmuItems[danmuItems.length - 1];
                        const baseDuration = 8.5;
                        lastItem.style.animationDuration = `${baseDuration / currentSpeed}s`;
                    }
                }, 10);

                document.getElementById('danmuInput').value = '';
                updateStatus(`已发送弹幕: ${text}`);
            }
        });

        // 新增：弹幕速度调节滑块事件监听
        document.getElementById('speedSlider').addEventListener('input', function () {
            const speedValue = parseFloat(this.value);
            document.getElementById('speedValue').textContent = speedValue.toFixed(1);
            if (dp && dp.danmaku) {
                // 保存当前速度设置
                dp.danmaku.speedRate = speedValue;

                // 清除所有现有弹幕
                dp.danmaku.clear();

                // 重置所有弹幕的sent标记，以便重新加载
                if (danmuList && danmuList.length > 0) {
                    danmuList.forEach(danmu => {
                        danmu.sent = false;
                    });
                }

                // 添加一个全局样式来控制所有弹幕的速度
                let speedStyle = document.getElementById('danmu-speed-style');
                if (!speedStyle) {
                    speedStyle = document.createElement('style');
                    speedStyle.id = 'danmu-speed-style';
                    document.head.appendChild(speedStyle);
                }

                // 计算新的动画时间（基于默认速度1.0）
                const baseDuration = 8.5; // DPlayer默认动画时间
                const newDuration = baseDuration / speedValue;

                // 更新全局样式
                speedStyle.textContent = `.dplayer-danmaku-item { animation-duration: ${newDuration}s !important; }`;

                updateStatus(`弹幕速度已调整为: ${speedValue.toFixed(1)}`);
            }
        });

        document.getElementById('danmuInput').addEventListener('keypress', function (e) {
            if (e.key === 'Enter') {
                document.getElementById('sendDanmu').click();
            }
        });

        document.getElementById('videoFile').addEventListener('change', function (e) {
            const file = e.target.files[0];
            const videoLabel = document.querySelector('label[for="videoFile"]');
            if (file) {
                videoUrl = URL.createObjectURL(file);
                document.querySelector('.player-card h1').textContent = file.name;
                updateStatus(`已加载视频文件: ${file.name}`);
                initPlayer();
                // 修改按钮文字
                if (videoLabel) videoLabel.textContent = `视频：${file.name}`;
            } else {
                if (videoLabel) videoLabel.textContent = '选择视频';
            }
        });

        // 新增：根据时间戳实时加载弹幕
        function setupDanmuRealtimeLoader() {
            if (!dp) return;
            // 重置所有弹幕的 sent 标记
            danmuList.forEach(d => d.sent = false);

            dp.on('timeupdate', function () {
                const currentTime = dp.video.currentTime;
                const currentSpeed = dp.danmaku.speedRate; // 获取当前速度设置

                // 只绘制当前时间±0.3秒内且未发送过的弹幕
                danmuList.forEach(danmu => {
                    if (!danmu.sent && Math.abs(danmu.time - currentTime) < 0.3) {
                        dp.danmaku.draw({
                            text: danmu.text,
                            color: danmu.color || '#ffffff',
                            type: danmu.type || 'right',
                            time: danmu.time
                        });

                        // 找到刚添加的弹幕并应用当前速度
                        setTimeout(() => {
                            const danmuItems = document.querySelectorAll('.dplayer-danmaku-item');
                            if (danmuItems.length > 0) {
                                const lastItem = danmuItems[danmuItems.length - 1];
                                const baseDuration = 8.5;
                                lastItem.style.animationDuration = `${baseDuration / currentSpeed}s`;
                            }
                        }, 0);

                        danmu.sent = true;
                    }
                });
            });

            // 当 seek 时，重置 sent 标记
            dp.on('seeked', function () {
                const currentTime = dp.video.currentTime;
                danmuList.forEach(danmu => {
                    danmu.sent = danmu.time < currentTime - 0.3;
                });
            });
        }

        document.getElementById('danmuFile').addEventListener('change', function (e) {
            const file = e.target.files[0];
            const danmuLabel = document.querySelector('label[for="danmuFile"]');
            if (file) {
                // 新增：选择弹幕后显示文件名
                if (danmuLabel) danmuLabel.textContent = `弹幕：${file.name}`;
                updateStatus(`正在解析弹幕文件: ${file.name}...`);
                const reader = new FileReader();
                reader.onload = async function (e) {
                    try {
                        // 使用Web Worker解析XML
                        updateStatus("正在解析弹幕(后台处理)...");
                        const startTime = performance.now();
                        const parsedDanmus = await parseDanmuWithWorker(e.target.result);
                        const endTime = performance.now();
                        updateStatus(`解析完成，耗时 ${(endTime - startTime).toFixed(2)}ms，共 ${parsedDanmus.length} 条弹幕`);
                        if (dp) {
                            // 新增：保存弹幕并启动实时加载
                            danmuList = parsedDanmus;
                            setupDanmuRealtimeLoader();
                            updateStatus("弹幕已准备，将随视频播放实时加载");
                        } else {
                            updateStatus('请先加载视频文件');
                        }
                    } catch (error) {
                        // Web Worker解析失败，尝试主线程解析
                        updateStatus("Web Worker解析失败，尝试主线程解析...");
                        console.warn("Web Worker解析失败:", error);

                        try {
                            const startTime = performance.now();
                            const parsedDanmus = parseDanmuXML(e.target.result);
                            const endTime = performance.now();

                            updateStatus(`主线程解析完成，耗时 ${(endTime - startTime).toFixed(2)}ms，共 ${parsedDanmus.length} 条弹幕`);

                            if (dp) {
                                updateStatus("开始加载弹幕到播放器...");
                                batchLoadDanmus(parsedDanmus);
                            }
                        } catch (error) {
                            updateStatus(`弹幕文件处理失败: ${error.message}`);
                            console.error(error);
                        }
                    }
                };
                reader.onerror = function () {
                    updateStatus('弹幕文件读取失败');
                };
                reader.readAsText(file);
            }
        });

        // 初始化
        updateStatus('请选择视频文件和弹幕文件');
    </script>
</body>

</html>