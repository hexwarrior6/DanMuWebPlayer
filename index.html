<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="favicon.png" type="image/x-icon">
    <title>本地弹幕播放器</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/dplayer/dist/DPlayer.min.css">
    <style>
        body {
            font-family: "HarmonyOS Sans", "PingFang SC", "Helvetica Neue", Arial, sans-serif;
            background: #f6f7fb;
            margin: 0;
            padding: 0;
        }

        .main-layout {
            display: flex;
            flex-direction: row;
            gap: 32px;
            max-width: 80%;
            margin: 48px auto 0 auto;
            padding: 0 16px;
        }

        @media (max-width: 900px) {
            .main-layout {
                flex-direction: column;
                gap: 20px;
                margin-top: 24px;
            }

            .controls input[type="text"] {
                max-width: 100%;
                /* 新增：在移动端允许宽度自适应父容器 */
                min-width: 0;
                /* 新增：防止flex导致的溢出 */
            }
        }

        .player-card {
            flex: 2;
            background: #fff;
            border-radius: 28px;
            box-shadow: 0 6px 32px 0 rgba(30, 34, 40, 0.10);
            padding: 32px 32px 24px 32px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #dplayer {
            width: 100%;
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 2px 12px 0 rgba(0, 0, 0, 0.06);
            margin-bottom: 32px;
            position: relative;
            aspect-ratio: 16/9;
            min-height: 360px;
            /* 提供一个最小高度作为备用 */
        }

        /* DPlayer加载后会创建自己的容器，确保它填满父元素 */
        #dplayer .dplayer-video-wrap {
            width: 100%;
            height: 100%;
        }

        #video-placeholder {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #bbb;
            font-size: 22px;
            background: #f7f8fa;
            z-index: 2;
            pointer-events: none;
            height: 100%;
            width: 100%;
        }

        #video-placeholder .icon {
            font-size: 60px;
            margin-bottom: 18px;
            color: #e3e5e7;
        }

        .controls {
            display: flex;
            gap: 18px;
            margin-bottom: 0;
            width: 100%;
            justify-content: center;
        }

        input[type="text"] {
            flex: 1;
            padding: 14px 18px;
            border: 2px solid #e3e5e7;
            border-radius: 14px;
            font-size: 18px;
            outline: none;
            background: #f7f8fa;
            transition: border 0.2s;
            max-width: 400px;
            /* 新增：限制最大宽度，防止超出 */
        }

        input[type="text"]:focus {
            border-color: #00A1D6;
        }

        button,
        .file-label {
            border: none;
            border-radius: 14px;
            font-size: 18px;
            font-weight: 600;
            padding: 14px 22px;
            background: #222;
            color: #fff;
            cursor: pointer;
            transition: background 0.2s, box-shadow 0.2s;
            box-shadow: 0 2px 8px 0 rgba(0, 0, 0, 0.08);
        }

        button:hover,
        .file-label:hover {
            background: #444;
        }

        button:disabled {
            background: #b8c0cc;
            cursor: not-allowed;
        }

        .file-input {
            display: none;
        }

        .status {
            margin-top: 18px;
            padding: 14px;
            background: #f2f3f7;
            border-radius: 14px;
            color: #555;
            font-size: 16px;
            text-align: center;
        }

        .progress-container {
            margin-top: 18px;
            display: none;
        }

        progress {
            width: 100%;
            height: 18px;
            border-radius: 9px;
            overflow: hidden;
            background: #e3e5e7;
            accent-color: #00A1D6;
        }

        #progressText {
            color: #00A1D6;
            font-weight: 600;
            margin-top: 6px;
            font-size: 16px;
            text-align: center;
        }

        .info-card {
            flex: 1;
            background: linear-gradient(135deg, #fafdff 60%, #e9f3ff 100%);
            border-radius: 32px;
            box-shadow: 0 8px 36px 0 rgba(30, 34, 40, 0.13), 0 1.5px 6px 0 rgba(0, 161, 214, 0.06);
            padding: 20px;
            /* 减少上下内边距 */
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 260px;
            max-width: 340px;
            border: 1.5px solid #e3e5e7;
            position: relative;
            overflow: hidden;
        }

        .avatar {
            width: 70px;
            /* 缩小头像 */
            height: 70px;
            /* 缩小头像 */
            border-radius: 50%;
            background: #e3e5e7;
            margin-bottom: 16px;
            /* 减少间距 */
            object-fit: cover;
            border: 3px solid #fff;
            box-shadow: 0 2px 12px 0 rgba(0, 161, 214, 0.08);
        }

        .info-detail {
            font-size: 15px;
            /* 略微缩小字体 */
            color: #4a6fa1;
            margin-bottom: 16px;
            /* 减少间距 */
            text-align: center;
            background: #f2f7fb;
            border-radius: 10px;
            padding: 6px 10px;
            /* 减少内边距 */
        }

        .info-section {
            width: 100%;
            margin-bottom: 8px;
            /* 减少下间距 */
            margin-top: 12px;
            /* 减少上间距 */
            position: relative;
        }

        .info-section:not(:first-child) {
            margin-top: 16px;
            /* 调整分割线和内容间距 */
        }

        .info-section:not(:first-child)::before {
            content: "";
            display: block;
            width: 60%;
            /* 缩短分割线 */
            height: 1px;
            /* 变细分割线 */
            background: linear-gradient(90deg, #e3e5e7 0%, #b8c0cc 100%);
            margin: 0 auto 12px auto;
            /* 调整分割线上下间距 */
            border-radius: 1px;
        }

        .info-section b {
            /* 为分区标题添加样式 */
            display: block;
            text-align: left;
            font-size: 16px;
            color: #333;
            margin-bottom: 8px;
            margin-left: 20px;
        }

        .info-section ul {
            padding-left: 0;
            margin: 8px 0 0 0;
            /* 调整列表边距 */
            color: #3a4a5a;
            font-size: 14px;
            /* 缩小列表字体 */
            list-style: none;
            text-align: center;
            /* 居中列表项 */
        }

        .info-section ul li {
            margin-bottom: 5px;
            /* 减少列表项间距 */
            display: inline-block;
            /* 让列表项水平排列，如果需要 */
            margin-right: 10px;
            /* 如果水平排列，添加右边距 */
            align-items: start;
            /* 确保列表项对齐 */
            text-align: left;
            /* 确保文本对齐 */
            display: flex;
            /* 确保项目符号对齐 */
            margin-left: 20px;
        }

        .info-section ul li::before {
            content: "•";
            color: #00A1D6;
            font-size: 16px;
            /* 调整项目符号大小 */
            margin-right: 6px;
            /* 调整项目符号间距 */
            line-height: 1;
        }

        /* 统一文件选择标签和输入框组样式 */
        .file-control-group {
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
            margin-top: 8px;
            /* 减少与标题的间距 */
        }

        .file-label,
        .input-group-container {
            /* 应用于标签和输入框组容器 */
            display: block;
            /* 或 flex */
            width: 100%;
            /* 统一宽度 */
            max-width: 300px;
            /* 设置最大宽度 */
            margin-left: auto;
            margin-right: auto;
            box-sizing: border-box;
        }

        .input-group-container {
            /* 特指输入框+按钮的容器 */
            display: flex;
            gap: 8px;
            height: 48px;
            /* 保持高度一致 */
            padding: 0;
            /* 移除容器的内边距 */
        }

        /* 弹幕速度滑块美化 */
        #speedSlider {
            width: 87%;
            height: 8px;
            border-radius: 4px;
            background: linear-gradient(90deg, #00A1D6 0%, #e3e5e7 100%);
            outline: none;
            accent-color: #00A1D6;
            margin: auto;
            display: flex;
        }

        #speedSlider::-webkit-slider-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #fff;
            border: 2px solid #00A1D6;
            box-shadow: 0 2px 6px 0 rgba(0, 161, 214, 0.10);
            cursor: pointer;
            transition: background 0.2s;
        }

        #speedSlider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #fff;
            border: 2px solid #00A1D6;
            box-shadow: 0 2px 6px 0 rgba(0, 161, 214, 0.10);
            cursor: pointer;
            transition: background 0.2s;
        }

        #speedSlider::-ms-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #fff;
            border: 2px solid #00A1D6;
            box-shadow: 0 2px 6px 0 rgba(0, 161, 214, 0.10);
            cursor: pointer;
            transition: background 0.2s;
        }

        #speedValue {
            color: #00A1D6;
            font-weight: bold;
            font-size: 17px;
            margin-right: 25px;
        }

        .file-input-style {
            flex: 1;
            border: 2px solid #e3e5e7;
            border-radius: 14px;
            font-size: 16px;
            /* 缩小字体 */
            outline: none;
            background: #f7f8fa;
            transition: border 0.2s;
            height: 100%;
            /* 继承父容器高度 */
            box-sizing: border-box;
            padding: 0 12px;
            /* 调整内边距 */
            min-width: 0;
            /* 防止 flex 溢出 */
        }

        .danmu-fetch-btn {
            padding: 0 18px;
            /* 调整内边距以适应高度 */
            font-size: 16px;
            /* 缩小字体 */
            border-radius: 14px;
            font-weight: 600;
            background: #222;
            color: #fff;
            border: none;
            cursor: pointer;
            transition: background 0.2s, box-shadow 0.2s;
            box-shadow: 0 2px 8px 0 rgba(0, 0, 0, 0.08);
            height: 100%;
            /* 继承父容器高度 */
            width: 80px;
            /* 固定宽度 */
            flex-shrink: 0;
        }

        .danmu-fetch-btn:hover {
            background: #444;
        }
    </style>
</head>

<body>
    <div class="main-layout">
        <div class="player-card">
            <h1>本地弹幕播放器</h1>
            <div id="dplayer">
                <div id="video-placeholder">
                    <div class="icon">▶️</div>
                    <div>请先选择本地视频文件</div>
                </div>
            </div>
            <div class="controls">
                <input type="text" id="danmuInput" placeholder="输入弹幕内容">
                <button id="sendDanmu">发送</button>
            </div>
            <div class="progress-container" id="progressContainer">
                <progress id="loadProgress" value="0" max="100"></progress>
                <div id="progressText">加载中: 0%</div>
            </div>
            <div class="status" id="status">等待加载视频和弹幕...</div>
        </div>
        <div class="info-card">
            <img class="avatar" src="favicon.png" alt="favicon">
            <div class="info-detail">本地弹幕播放器，支持本地视频与弹幕文件播放。</div> <!-- 精简描述 -->
            <div class="info-section">
                <b>使用方法：</b>
                <!-- 保持 ul 样式或根据需要调整 -->
                <ul style="padding-left: 0; margin: 8px 0 0 0; color: #444; font-size: 14px; text-align: center;">
                    <li>选择本地视频和弹幕文件</li>
                    <li>播放视频即可实时显示弹幕</li>
                </ul>
            </div>

            <!-- 弹幕速度调节滑块 -->
            <div class="info-section">
                <!-- 保持内部结构不变 -->
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                    <b>弹幕速度：</b>
                    <span id="speedValue">1.0</span>
                </div>
                <input type="range" id="speedSlider" min="0.1" max="2" step="0.1" value="1">
            </div>

            <!-- 上传视频区域 -->
            <div class="info-section">
                <b>上传视频：</b>
                <div class="file-control-group"> <!-- 应用新类 -->
                    <label for="videoFile" class="file-label">选择本地视频文件</label> <!-- 移除内联 width -->
                    <input type="file" id="videoFile" class="file-input" accept="video/mp4">
                </div>
            </div>

            <!-- 上传弹幕区域 -->
            <div class="info-section">
                <b>上传弹幕（任选一种）：</b>
                <div class="file-control-group"> <!-- 应用新类 -->
                    <label for="danmuFileXml" class="file-label">标准XML弹幕</label> <!-- 移除内联 width -->
                    <input type="file" id="danmuFileXml" class="file-input" accept=".xml">
                    <label for="danmuFileJson" class="file-label">人人视频JSON弹幕</label> <!-- 移除内联 width -->
                    <input type="file" id="danmuFileJson" class="file-input" accept=".json">
                    <!-- 应用新容器类，移除内联样式 -->
                    <div class="input-group-container">
                        <input type="text" id="rrmjDanmuIdInput" placeholder="输入人人视频弹幕ID" class="file-input-style">
                        <!-- 移除内联 style -->
                        <button id="rrmjDanmuFetchBtn" class="danmu-fetch-btn">获取</button> <!-- 移除内联 style -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 引入必要的库 -->
    <script src="https://cdn.jsdelivr.net/npm/dplayer/dist/DPlayer.min.js"></script>

    <script>
        // 全局变量
        let dp;
        let videoUrl = '';
        let danmuList = []; // 存储弹幕
        let loadingWorker = null;
        let isCancelled = false;

        updateStatus('请选择视频文件和弹幕文件');

        // 修改 initPlayer：选择视频后初始化 DPlayer，并隐藏占位层
        function initPlayer() {
            // 隐藏占位层
            const placeholder = document.getElementById('video-placeholder');
            if (placeholder) placeholder.style.display = 'none';

            // 获取当前设置的弹幕速度
            const speedRate = parseFloat(document.getElementById('speedSlider').value);

            // 添加全局样式控制弹幕速度
            let speedStyle = document.getElementById('danmu-speed-style');
            if (!speedStyle) {
                speedStyle = document.createElement('style');
                speedStyle.id = 'danmu-speed-style';
                document.head.appendChild(speedStyle);
            }

            // 计算动画时间
            const baseDuration = 8.5;
            const newDuration = baseDuration / speedRate;

            // 更新全局样式
            speedStyle.textContent = `.dplayer-danmaku-item { animation-duration: ${newDuration}s !important; }`;

            dp = new DPlayer({
                container: document.getElementById('dplayer'),
                autoplay: false,
                theme: '#FADFA3',
                video: {
                    url: videoUrl,
                    type: 'auto'
                },
                danmaku: {
                    id: 'local-danmu',
                    api: '',
                    maximum: 1000,
                    addition: [],
                    user: '观众',
                    speedRate: speedRate,
                },
                contextmenu: []
            });
            dp.seek(0);
            updateStatus(`播放器已初始化，等待加载弹幕...`);
        }

        // 更新状态显示
        function updateStatus(message) {
            document.getElementById('status').textContent = message;
        }

        // 批量加载弹幕
        function batchLoadDanmus(danmus, batchSize = 100) {
            const progressContainer = document.getElementById('progressContainer');
            const progressBar = document.getElementById('loadProgress');
            const progressText = document.getElementById('progressText');

            progressContainer.style.display = 'block';
            progressBar.value = 0;
            progressText.textContent = '加载中: 0%';

            let loaded = 0;
            const total = danmus.length;
            isCancelled = false;

            document.getElementById('cancelLoad').disabled = false;

            function loadNextBatch() {
                if (isCancelled) {
                    updateStatus(`已取消加载，已加载 ${loaded}/${total} 条弹幕`);
                    progressContainer.style.display = 'none';
                    document.getElementById('cancelLoad').disabled = true;
                    return;
                }

                const batchEnd = Math.min(loaded + batchSize, total);

                // 修改：逐条添加弹幕
                for (let i = loaded; i < batchEnd; i++) {
                    const danmu = danmus[i];
                    dp.danmaku && dp.danmaku.draw({
                        text: danmu.text,
                        color: danmu.color || '#ffffff',
                        type: danmu.type || 'right',
                        time: danmu.time
                    });
                }

                loaded = batchEnd;
                const percent = Math.round((loaded / total) * 100);
                progressBar.value = percent;
                progressText.textContent = `加载中: ${percent}% (${loaded}/${total})`;

                if (loaded < total) {
                    setTimeout(loadNextBatch, 0);
                } else {
                    updateStatus(`成功加载 ${total} 条弹幕`);
                    progressContainer.style.display = 'none';
                    document.getElementById('cancelLoad').disabled = true;
                }
            }

            loadNextBatch();
        }

        // 使用正则表达式解析XML (兼容Web Worker环境)
        function parseDanmuWithRegex(xmlText) {
            const danmuRegex = /<d p="([^"]+)">([^<]+)<\/d>/g;
            const result = [];
            let match;

            while ((match = danmuRegex.exec(xmlText)) !== null) {
                const attrs = match[1].split(',');
                const text = match[2];

                if (attrs.length >= 8) {
                    const time = parseFloat(attrs[0]);
                    const type = parseInt(attrs[1]);
                    const color = parseInt(attrs[3]);

                    if (type === 1) { // 只处理滚动弹幕
                        result.push({
                            text: text,
                            color: '#' + color.toString(16).padStart(6, '0'),
                            type: 'right',
                            time: time
                        });
                    }
                }
            }

            return result;
        }

        // 使用Web Worker解析XML (使用正则表达式替代DOMParser)
        function parseDanmuWithWorker(xmlText) {
            return new Promise((resolve, reject) => {
                if (window.Worker) {
                    const worker = new Worker(URL.createObjectURL(
                        new Blob([`
                            function parseDanmuXML(xmlText) {
                                try {
                                    const danmuRegex = /<d p="([^"]+)">([^<]+)<\\/d>/g;
                                    const result = [];
                                    let match;
                                    
                                    while ((match = danmuRegex.exec(xmlText)) !== null) {
                                        const attrs = match[1].split(',');
                                        const text = match[2];
                                        
                                        if (attrs.length >= 8) {
                                            const time = parseFloat(attrs[0]);
                                            const type = parseInt(attrs[1]);
                                            const color = parseInt(attrs[3]);
                                            
                                            if (type === 1) {
                                                result.push({
                                                    text: text,
                                                    color: '#' + color.toString(16).padStart(6, '0'),
                                                    type: 'right',
                                                    time: time
                                                });
                                            }
                                        }
                                    }
                                    return result;
                                } catch (error) {
                                    throw error;
                                }
                            }
                            
                            self.onmessage = function(e) {
                                try {
                                    const result = parseDanmuXML(e.data);
                                    self.postMessage({ success: true, data: result });
                                } catch (error) {
                                    self.postMessage({ success: false, error: error.message });
                                }
                            };
                        `], { type: 'application/javascript' })
                    ));

                    worker.onmessage = function (e) {
                        if (e.data.success) {
                            resolve(e.data.data);
                        } else {
                            reject(new Error(e.data.error));
                        }
                        worker.terminate();
                    };

                    worker.onerror = function (error) {
                        reject(error);
                        worker.terminate();
                    };

                    worker.postMessage(xmlText);
                } else {
                    // 浏览器不支持Web Worker，回退到主线程解析
                    try {
                        const result = parseDanmuWithRegex(xmlText);
                        resolve(result);
                    } catch (error) {
                        reject(error);
                    }
                }
            });
        }

        // 主线程解析XML (使用DOMParser)
        function parseDanmuXML(xmlText) {
            try {
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlText, "text/xml");
                const danmus = xmlDoc.getElementsByTagName('d');
                const result = [];

                for (let i = 0; i < danmus.length; i++) {
                    const danmu = danmus[i];
                    const attrs = danmu.getAttribute('p').split(',');

                    if (attrs.length >= 8) {
                        const time = parseFloat(attrs[0]);
                        const type = parseInt(attrs[1]);
                        const color = parseInt(attrs[3]);

                        if (type === 1) {
                            result.push({
                                text: danmu.textContent,
                                color: '#' + color.toString(16).padStart(6, '0'),
                                type: 'right',
                                time: time
                            });
                        }
                    }
                }

                return result;
            } catch (error) {
                updateStatus(`弹幕解析失败: ${error.message}`);
                console.error('XML解析错误:', error);
                return [];
            }
        }

        // 事件监听
        document.getElementById('sendDanmu').addEventListener('click', function () {
            const text = document.getElementById('danmuInput').value;
            if (text.trim() !== '' && dp) {
                // 获取当前速度设置
                const currentSpeed = dp.danmaku.speedRate;

                dp.danmaku.draw({
                    text: text,
                    color: '#ffffff',
                    type: 'right'
                });

                // 确保新发送的弹幕使用当前速度
                setTimeout(() => {
                    const danmuItems = document.querySelectorAll('.dplayer-danmaku-item');
                    if (danmuItems.length > 0) {
                        const lastItem = danmuItems[danmuItems.length - 1];
                        const baseDuration = 8.5;
                        lastItem.style.animationDuration = `${baseDuration / currentSpeed}s`;
                    }
                }, 10);

                document.getElementById('danmuInput').value = '';
                updateStatus(`已发送弹幕: ${text}`);
            }
        });

        // 新增：弹幕速度调节滑块事件监听
        document.getElementById('speedSlider').addEventListener('input', function () {
            const speedValue = parseFloat(this.value);
            document.getElementById('speedValue').textContent = speedValue.toFixed(1);
            if (dp && dp.danmaku) {
                // 保存当前速度设置
                dp.danmaku.speedRate = speedValue;

                // 清除所有现有弹幕
                dp.danmaku.clear();

                // 重置所有弹幕的sent标记，以便重新加载
                if (danmuList && danmuList.length > 0) {
                    danmuList.forEach(danmu => {
                        danmu.sent = false;
                    });
                }

                // 添加一个全局样式来控制所有弹幕的速度
                let speedStyle = document.getElementById('danmu-speed-style');
                if (!speedStyle) {
                    speedStyle = document.createElement('style');
                    speedStyle.id = 'danmu-speed-style';
                    document.head.appendChild(speedStyle);
                }

                // 计算新的动画时间（基于默认速度1.0）
                const baseDuration = 8.5; // DPlayer默认动画时间
                const newDuration = baseDuration / speedValue;

                // 更新全局样式
                speedStyle.textContent = `.dplayer-danmaku-item { animation-duration: ${newDuration}s !important; }`;

                updateStatus(`弹幕速度已调整为: ${speedValue.toFixed(1)}`);
            }
        });

        document.getElementById('danmuInput').addEventListener('keypress', function (e) {
            if (e.key === 'Enter') {
                document.getElementById('sendDanmu').click();
            }
        });

        document.getElementById('videoFile').addEventListener('change', function (e) {
            const file = e.target.files[0];
            const videoLabel = document.querySelector('label[for="videoFile"]');
            if (file) {
                videoUrl = URL.createObjectURL(file);
                document.querySelector('.player-card h1').textContent = file.name;
                updateStatus(`已加载视频文件: ${file.name}`);
                initPlayer();
                // 修改按钮文字
                if (videoLabel) videoLabel.textContent = `视频：${file.name}`;
            } else {
                if (videoLabel) videoLabel.textContent = '选择视频';
            }
        });

        // 新增：根据时间戳实时加载弹幕
        function setupDanmuRealtimeLoader() {
            if (!dp) return;
            // 重置所有弹幕的 sent 标记
            danmuList.forEach(d => d.sent = false);

            dp.on('timeupdate', function () {
                const currentTime = dp.video.currentTime;
                const currentSpeed = dp.danmaku.speedRate; // 获取当前速度设置

                // 只绘制当前时间±0.3秒内且未发送过的弹幕
                danmuList.forEach(danmu => {
                    if (!danmu.sent && Math.abs(danmu.time - currentTime) < 0.3) {
                        dp.danmaku.draw({
                            text: danmu.text,
                            color: danmu.color || '#ffffff',
                            type: danmu.type || 'right',
                            time: danmu.time
                        });

                        // 找到刚添加的弹幕并应用当前速度
                        setTimeout(() => {
                            const danmuItems = document.querySelectorAll('.dplayer-danmaku-item');
                            if (danmuItems.length > 0) {
                                const lastItem = danmuItems[danmuItems.length - 1];
                                const baseDuration = 8.5;
                                lastItem.style.animationDuration = `${baseDuration / currentSpeed}s`;
                            }
                        }, 0);

                        danmu.sent = true;
                    }
                });
            });

            // 当 seek 时，重置 sent 标记
            dp.on('seeked', function () {
                const currentTime = dp.video.currentTime;
                danmuList.forEach(danmu => {
                    danmu.sent = danmu.time < currentTime - 0.3;
                });
            });
        }

        // 删除原有的 danmuFile 相关监听
        // document.getElementById('danmuFile').addEventListener(...);  // ← 删除这一段

        // 新增：标准XML弹幕监听
        document.getElementById('danmuFileXml').addEventListener('change', function (e) {
            const file = e.target.files[0];
            const danmuLabel = document.querySelector('label[for="danmuFileXml"]');
            if (file) {
                if (danmuLabel) danmuLabel.textContent = `标准XML弹幕：${file.name}`;
                updateStatus(`正在解析弹幕文件: ${file.name}...`);
                const reader = new FileReader();
                reader.onload = async function (e) {
                    try {
                        updateStatus("正在解析弹幕(后台处理)...");
                        const startTime = performance.now();
                        const parsedDanmus = await parseDanmuWithWorker(e.target.result);
                        const endTime = performance.now();
                        updateStatus(`解析完成，耗时 ${(endTime - startTime).toFixed(2)}ms，共 ${parsedDanmus.length} 条弹幕`);
                        if (dp) {
                            danmuList = parsedDanmus;
                            setupDanmuRealtimeLoader();
                            updateStatus("弹幕已准备，将随视频播放实时加载");
                        } else {
                            updateStatus('请先加载视频文件');
                        }
                    } catch (error) {
                        updateStatus("弹幕解析失败: " + error.message);
                        console.error(error);
                    }
                };
                reader.onerror = function () {
                    updateStatus('弹幕文件读取失败');
                };
                reader.readAsText(file);
            }
        });

        // 新增：人人视频弹幕监听
        document.getElementById('danmuFileJson').addEventListener('change', function (e) {
            const file = e.target.files[0];
            const danmuLabel = document.querySelector('label[for="danmuFileJson"]');
            if (file) {
                if (danmuLabel) danmuLabel.textContent = `人人视频JSON弹幕：${file.name}`;
                updateStatus(`正在解析人人视频JSON弹幕文件: ${file.name}...`);
                const reader = new FileReader();
                reader.onload = function (e) {
                    try {
                        updateStatus("正在解析人人视频JSON弹幕...");
                        const startTime = performance.now();
                        const parsedDanmus = parseDanmuJSON(e.target.result);
                        const endTime = performance.now();
                        updateStatus(`人人视频JSON弹幕解析完成，耗时 ${(endTime - startTime).toFixed(2)}ms，共 ${parsedDanmus.length} 条弹幕`);
                        if (dp) {
                            danmuList = parsedDanmus;
                            setupDanmuRealtimeLoader();
                            updateStatus("弹幕已准备，将随视频播放实时加载");
                        } else {
                            updateStatus('请先加载视频文件');
                        }
                    } catch (error) {
                        updateStatus("人人视频JSON弹幕解析失败: " + error.message);
                        console.error(error);
                    }
                };
                reader.onerror = function () {
                    updateStatus('弹幕文件读取失败');
                };
                reader.readAsText(file);
            }
        });

        // 初始化
        updateStatus('请选择视频文件和弹幕文件');

        // 新增：解析 JSON 弹幕
        function parseDanmuJSON(jsonText) {
            let result = [];
            try {
                const arr = JSON.parse(jsonText);
                for (const item of arr) {
                    if (item.p && item.d) {
                        const attrs = item.p.split(',');
                        if (attrs.length >= 8) {
                            const time = parseFloat(attrs[0]);
                            const type = parseInt(attrs[1]);
                            const color = parseInt(attrs[3]);
                            if (type === 1) {
                                result.push({
                                    text: item.d,
                                    color: '#' + color.toString(16).padStart(6, '0'),
                                    type: 'right',
                                    time: time
                                });
                            }
                        }
                    }
                }
            } catch (e) {
                updateStatus('人人视频弹幕解析失败: ' + e.message);
                console.error(e);
            }
            return result;
        }
        // 新增：人人视频弹幕ID获取功能
        document.getElementById('rrmjDanmuFetchBtn').addEventListener('click', async function () {
            const id = document.getElementById('rrmjDanmuIdInput').value.trim();
            if (!id) {
                updateStatus('请输入人人视频弹幕ID');
                return;
            }
            updateStatus('正在从人人视频接口获取弹幕...');
            try {
                const url = `https://static-dm.rrmj.plus/v1/produce/danmu/EPISODE/${id}`;
                const resp = await fetch(url);
                if (!resp.ok) {
                    updateStatus('弹幕接口请求失败');
                    return;
                }
                const json = await resp.json();
                // 人人视频接口返回格式通常为 { code: 0, data: [...] }
                let danmuArr = [];
                if (Array.isArray(json)) {
                    danmuArr = json;
                } else if (json && Array.isArray(json.data)) {
                    danmuArr = json.data;
                }
                if (danmuArr.length === 0) {
                    updateStatus('未获取到弹幕数据');
                    return;
                }
                const parsedDanmus = parseDanmuJSON(JSON.stringify(danmuArr));
                if (dp) {
                    danmuList = parsedDanmus;
                    setupDanmuRealtimeLoader();
                    updateStatus("弹幕已准备，将随视频播放实时加载");
                } else {
                    updateStatus('请先加载视频文件');
                }
            } catch (e) {
                updateStatus('获取人人视频弹幕失败: ' + e.message);
                console.error(e);
            }
        });
    </script>
</body>

</html>