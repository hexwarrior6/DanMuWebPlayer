<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="favicon.png" type="image/x-icon">
    <title>本地弹幕播放器</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/dplayer/dist/DPlayer.min.css">
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        h1 {
            text-align: center;
            color: #333;
        }
        #dplayer {
            margin: 20px 0;
        }
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        input, button {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        button {
            background-color: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
            font-size: 16px; /* 新增：统一按钮字体大小 */
        }
        button:hover {
            background-color: #45a049;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        .file-input {
            display: none;
        }
        .file-label {
            padding: 8px 12px;
            background-color: #2196F3;
            color: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px; /* 新增：统一文件选择标签字体大小 */
        }
        .status {
            margin-top: 10px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 4px;
        }
        .progress-container {
            margin-top: 10px;
            display: none;
        }
        progress {
            width: 100%;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>本地弹幕播放器</h1>
        
        <div class="controls">
            <input type="text" id="danmuInput" placeholder="输入弹幕内容" style="flex-grow: 1;">
            <button id="sendDanmu">发送弹幕</button>
            <label for="videoFile" class="file-label">选择视频</label>
            <input type="file" id="videoFile" class="file-input" accept="video/mp4">
            <label for="danmuFile" class="file-label">选择弹幕</label>
            <input type="file" id="danmuFile" class="file-input" accept=".xml">
            <button id="cancelLoad" disabled>取消加载</button>
        </div>
        
        <div class="progress-container" id="progressContainer">
            <progress id="loadProgress" value="0" max="100"></progress>
            <div id="progressText">加载中: 0%</div>
        </div>
        
        <div id="dplayer"></div>
        <div class="status" id="status">等待加载视频和弹幕...</div>
    </div>

    <!-- 引入必要的库 -->
    <script src="https://cdn.jsdelivr.net/npm/dplayer/dist/DPlayer.min.js"></script>
    
    <script>
        // 全局变量
        let dp;
        let videoUrl = '';
        let danmuList = []; // 存储弹幕
        let loadingWorker = null;
        let isCancelled = false;
        
        // 初始化播放器
        function initPlayer() {
            if (dp) {
                dp.destroy();
            }
            
            dp = new DPlayer({
                container: document.getElementById('dplayer'),
                autoplay: false,
                theme: '#FADFA3',
                video: {
                    url: videoUrl,
                    type: 'auto'
                },
                danmaku: {
                    id: 'local-danmu',
                    api: '', // 不使用远程API
                    maximum: 1000,
                    addition: [], // 不使用额外弹幕源
                    user: '观众'
                },
                contextmenu: []
            });
            
            updateStatus(`播放器已初始化，等待加载弹幕...`);
        }
        
        // 更新状态显示
        function updateStatus(message) {
            document.getElementById('status').textContent = message;
        }
        
        // 批量加载弹幕
        function batchLoadDanmus(danmus, batchSize = 100) {
            const progressContainer = document.getElementById('progressContainer');
            const progressBar = document.getElementById('loadProgress');
            const progressText = document.getElementById('progressText');
            
            progressContainer.style.display = 'block';
            progressBar.value = 0;
            progressText.textContent = '加载中: 0%';
            
            let loaded = 0;
            const total = danmus.length;
            isCancelled = false;
            
            document.getElementById('cancelLoad').disabled = false;
            
            function loadNextBatch() {
                if (isCancelled) {
                    updateStatus(`已取消加载，已加载 ${loaded}/${total} 条弹幕`);
                    progressContainer.style.display = 'none';
                    document.getElementById('cancelLoad').disabled = true;
                    return;
                }
                
                const batchEnd = Math.min(loaded + batchSize, total);

                // 修改：逐条添加弹幕
                for (let i = loaded; i < batchEnd; i++) {
                    const danmu = danmus[i];
                    dp.danmaku && dp.danmaku.draw({
                        text: danmu.text,
                        color: danmu.color || '#ffffff',
                        type: danmu.type || 'right',
                        time: danmu.time
                    });
                }

                loaded = batchEnd;
                const percent = Math.round((loaded / total) * 100);
                progressBar.value = percent;
                progressText.textContent = `加载中: ${percent}% (${loaded}/${total})`;
                
                if (loaded < total) {
                    setTimeout(loadNextBatch, 0);
                } else {
                    updateStatus(`成功加载 ${total} 条弹幕`);
                    progressContainer.style.display = 'none';
                    document.getElementById('cancelLoad').disabled = true;
                }
            }
            
            loadNextBatch();
        }
        
        // 使用正则表达式解析XML (兼容Web Worker环境)
        function parseDanmuWithRegex(xmlText) {
            const danmuRegex = /<d p="([^"]+)">([^<]+)<\/d>/g;
            const result = [];
            let match;
            
            while ((match = danmuRegex.exec(xmlText)) !== null) {
                const attrs = match[1].split(',');
                const text = match[2];
                
                if (attrs.length >= 8) {
                    const time = parseFloat(attrs[0]);
                    const type = parseInt(attrs[1]);
                    const color = parseInt(attrs[3]);
                    
                    if (type === 1) { // 只处理滚动弹幕
                        result.push({
                            text: text,
                            color: '#' + color.toString(16).padStart(6, '0'),
                            type: 'right',
                            time: time
                        });
                    }
                }
            }
            
            return result;
        }
        
        // 使用Web Worker解析XML (使用正则表达式替代DOMParser)
        function parseDanmuWithWorker(xmlText) {
            return new Promise((resolve, reject) => {
                if (window.Worker) {
                    const worker = new Worker(URL.createObjectURL(
                        new Blob([`
                            function parseDanmuXML(xmlText) {
                                try {
                                    const danmuRegex = /<d p="([^"]+)">([^<]+)<\\/d>/g;
                                    const result = [];
                                    let match;
                                    
                                    while ((match = danmuRegex.exec(xmlText)) !== null) {
                                        const attrs = match[1].split(',');
                                        const text = match[2];
                                        
                                        if (attrs.length >= 8) {
                                            const time = parseFloat(attrs[0]);
                                            const type = parseInt(attrs[1]);
                                            const color = parseInt(attrs[3]);
                                            
                                            if (type === 1) {
                                                result.push({
                                                    text: text,
                                                    color: '#' + color.toString(16).padStart(6, '0'),
                                                    type: 'right',
                                                    time: time
                                                });
                                            }
                                        }
                                    }
                                    return result;
                                } catch (error) {
                                    throw error;
                                }
                            }
                            
                            self.onmessage = function(e) {
                                try {
                                    const result = parseDanmuXML(e.data);
                                    self.postMessage({ success: true, data: result });
                                } catch (error) {
                                    self.postMessage({ success: false, error: error.message });
                                }
                            };
                        `], { type: 'application/javascript' })
                    ));
                    
                    worker.onmessage = function(e) {
                        if (e.data.success) {
                            resolve(e.data.data);
                        } else {
                            reject(new Error(e.data.error));
                        }
                        worker.terminate();
                    };
                    
                    worker.onerror = function(error) {
                        reject(error);
                        worker.terminate();
                    };
                    
                    worker.postMessage(xmlText);
                } else {
                    // 浏览器不支持Web Worker，回退到主线程解析
                    try {
                        const result = parseDanmuWithRegex(xmlText);
                        resolve(result);
                    } catch (error) {
                        reject(error);
                    }
                }
            });
        }
        
        // 主线程解析XML (使用DOMParser)
        function parseDanmuXML(xmlText) {
            try {
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlText, "text/xml");
                const danmus = xmlDoc.getElementsByTagName('d');
                const result = [];
                
                for (let i = 0; i < danmus.length; i++) {
                    const danmu = danmus[i];
                    const attrs = danmu.getAttribute('p').split(',');
                    
                    if (attrs.length >= 8) {
                        const time = parseFloat(attrs[0]);
                        const type = parseInt(attrs[1]);
                        const color = parseInt(attrs[3]);
                        
                        if (type === 1) {
                            result.push({
                                text: danmu.textContent,
                                color: '#' + color.toString(16).padStart(6, '0'),
                                type: 'right',
                                time: time
                            });
                        }
                    }
                }
                
                return result;
            } catch (error) {
                updateStatus(`弹幕解析失败: ${error.message}`);
                console.error('XML解析错误:', error);
                return [];
            }
        }
        
        // 事件监听
        document.getElementById('sendDanmu').addEventListener('click', function() {
            const text = document.getElementById('danmuInput').value;
            if (text.trim() !== '' && dp) {
                dp.danmaku.draw({
                    text: text,
                    color: '#ffffff',
                    type: 'right'
                });
                document.getElementById('danmuInput').value = '';
                updateStatus(`已发送弹幕: ${text}`);
            }
        });
        
        document.getElementById('danmuInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                document.getElementById('sendDanmu').click();
            }
        });
        
        document.getElementById('videoFile').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                videoUrl = URL.createObjectURL(file);
                updateStatus(`已加载视频文件: ${file.name}`);
                initPlayer();
            }
        });
        
        // 新增：根据时间戳实时加载弹幕
        function setupDanmuRealtimeLoader() {
            if (!dp) return;
            // 重置所有弹幕的 sent 标记
            danmuList.forEach(d => d.sent = false);
        
            dp.on('timeupdate', function() {
                const currentTime = dp.video.currentTime;
                // 只绘制当前时间±0.3秒内且未发送过的弹幕
                danmuList.forEach(danmu => {
                    if (!danmu.sent && Math.abs(danmu.time - currentTime) < 0.3) {
                        dp.danmaku.draw({
                            text: danmu.text,
                            color: danmu.color || '#ffffff',
                            type: danmu.type || 'right',
                            time: danmu.time
                        });
                        danmu.sent = true;
                    }
                });
            });
        
            // 当 seek 时，重置 sent 标记
            dp.on('seeked', function() {
                const currentTime = dp.video.currentTime;
                danmuList.forEach(danmu => {
                    danmu.sent = danmu.time < currentTime - 0.3;
                });
            });
        }
        
        document.getElementById('danmuFile').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                updateStatus(`正在解析弹幕文件: ${file.name}...`);
                const reader = new FileReader();
                reader.onload = async function(e) {
                    try {
                        // 使用Web Worker解析XML
                        updateStatus("正在解析弹幕(后台处理)...");
                        const startTime = performance.now();
                        const parsedDanmus = await parseDanmuWithWorker(e.target.result);
                        const endTime = performance.now();
                        updateStatus(`解析完成，耗时 ${(endTime - startTime).toFixed(2)}ms，共 ${parsedDanmus.length} 条弹幕`);
                        if (dp) {
                            // 新增：保存弹幕并启动实时加载
                            danmuList = parsedDanmus;
                            setupDanmuRealtimeLoader();
                            updateStatus("弹幕已准备，将随视频播放实时加载");
                        } else {
                            updateStatus('请先加载视频文件');
                        }
                    } catch (error) {
                        // Web Worker解析失败，尝试主线程解析
                        updateStatus("Web Worker解析失败，尝试主线程解析...");
                        console.warn("Web Worker解析失败:", error);
                        
                        try {
                            const startTime = performance.now();
                            const parsedDanmus = parseDanmuXML(e.target.result);
                            const endTime = performance.now();
                            
                            updateStatus(`主线程解析完成，耗时 ${(endTime - startTime).toFixed(2)}ms，共 ${parsedDanmus.length} 条弹幕`);
                            
                            if (dp) {
                                updateStatus("开始加载弹幕到播放器...");
                                batchLoadDanmus(parsedDanmus);
                            }
                        } catch (error) {
                            updateStatus(`弹幕文件处理失败: ${error.message}`);
                            console.error(error);
                        }
                    }
                };
                reader.onerror = function() {
                    updateStatus('弹幕文件读取失败');
                };
                reader.readAsText(file);
            }
        });
        
        document.getElementById('cancelLoad').addEventListener('click', function() {
            isCancelled = true;
            this.disabled = true;
        });
        
        // 初始化
        updateStatus('请选择视频文件和弹幕文件');
    </script>
</body>
</html>